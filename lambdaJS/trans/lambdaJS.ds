module trans/lambdaJS

imports
src-gen/ds-signatures/lambdaJS-sig

signature
	sorts
		V

	constructors
		ObjV : Map(V,V) -> V
		StrV : String -> V
		NumV : INT -> V
		BoolV : BOOLEAN -> V
		UndefV : V
		NullV : V
		ClosV : Env * List(String) * Exp -> V 

	sort aliases
		Env = Map(String, V)


	components
		E : Env
		O : Map(V,V)
		
	variables
	    v : V
  
  	arrows
		bindVar(String, V) --> Env
		
		bindProperty(V, V) --> Map(V,V)
		removeProperty(V) --> Map(V,V)
		getProperty(V) --> V
		listToObj(List(Field)) --> Map(V,V)
		
		Start -init-> V
		Exp --> V
		Val --> V
		Field --> V

	rules
		O |- bindProperty(v1, v2) --> {O, v1 |--> v2}	
		O |- removeProperty(strv) --> O \ strv
		O |- getProperty(strv) --> O[strv]

//		E |- bindVar(x, v) --> {x |--> v, E}

		//TODO: init rule -> adjust to list of exps
		Program(e) -init-> v
		where
			e --> v
			
		Value(e) --> val
		where
			e --> val
		
		INT(i) --> NumV(i)
		
		BOOLEAN(i) --> BoolV(i)
		
		UNDEFINED(_) --> UndefV()
		
		NULL(_) --> NullV()
		
		STRING(i) --> StrV(i)
		
		Obj(propList) --> ObjV(obj)
		where
			{} => O;
			O |- listToObj(propList) --> obj
		
		Prop(name, _) --> StrV(name)
		
		O |- listToObj([]) --> O
			
		O |- listToObj([Prop(name, val) | listRest]) --> obj2
		where
			Prop(name, val) --> v1;
			val --> v2;
			O |- bindProperty(v1,v2) --> O2;
			O2 |- listToObj(listRest) --> obj2

		Get(e1, e2) --> v2
		where
			e1 --> ObjV(O);
			e2 --> v1;
			case O[v1?] of {
				true =>
					O |- getProperty(v1) --> v2		
				false =>
					UndefV() => v2
			}


//		Instantiation(e1, e2, e3) --> ObjV(obj2)
//		where
//			e1 --> ObjV(O);
//			e2 --> StrV(name);
//			e3 --> v1;
//			O |- bindProperty(name, v1) --> obj2		
		
		Delete(e1, e2) --> ObjV(obj2)
		where
			e1 --> ObjV(O);
			e2 --> v;
			case O[v?] of {
				true =>
					O |- removeProperty(v) --> obj2		
				false =>
					O => obj2	
			}
	
//		Let(x, v1, e2) --> v2
//  		where
//			E bindVar(x, v1) |- e2 --> v2
//	